# (c) 2025 Jonathan Brandt
# Licensed under the MIT License. See LICENSE file in the project root.

import re
import string
from pathlib import Path
from copy import copy
from datetime import datetime

from openpyxl import load_workbook
from openpyxl.worksheet.formula import ArrayFormula
from openpyxl.formula.translate import Translator
from openpyxl.utils.cell import get_column_letter

from birddog.utility import get_text, get_logger
from birddog.ai import classify_table_columns
from birddog.wiki import ARCHIVE_BASE

_logger = get_logger()

# ------------ HELPER FUNCTIONS ---------------

def _format_date(date_str):
    """
    Converts a date string from 'YYYY,MM,DD,hh:mm' to 'DD Mon YYYY'.
    
    Example:
        format_date('2024,04,14,07:30') -> '14 Apr 2024'
    """
    if not date_str:
        return ''
    dt = datetime.strptime(date_str, "%Y,%m,%d,%H:%M")
    return dt.strftime("%d %b %Y")

def _is_linked(url):
    return url and not "redlink" in url

def _link_status(url):
    return "linked" if _is_linked(url) else "unlinked"

def _child_url(child):
    link = child[0]["link"]
    return ARCHIVE_BASE + link if link is not None else None

def _child_sheetname(page, child):
    if page.kind == 'archive':
        return f'Fund {get_text(child[0]["text"])}'
    elif page.kind == 'fond':
        return f'{page.parent.id} {page.id}-{get_text(child[0]["text"])}'
    return f'sheetname-{get_text(child[0]["text"])}'

def _child_doc_url(parent, child, lru=None):
    _logger.info(f'_child_doc_url: _child_url {_child_url(child)}')
    if not child or not _is_linked(_child_url(child)):
        _logger.info(f'_child_doc_url: {parent.name}: unlinked {get_text(child[0]["text"])}')
        return None
    child_id = get_text(child[0]['text'])
    _logger.info(f'_child_doc_url: {parent.name}: looking up {child_id}')
    if lru:
        child = lru.lookup_child(parent, child_id)
    else:
        child = parent[child_id]
    return child.doc_url if child else None

_EXPR_PATTERN = re.compile(r'{[^}]+}')

def _check_string(text):
    if not text:
        return None
    if not isinstance(text, str):
        return text
    match = re.findall(_EXPR_PATTERN, text)
    if not match:
        return None
    return list(match)

def _get_cell_text(cell):
    text = cell.value
    if isinstance(text, ArrayFormula):
        text = text.text
    return text

def _check_cell(cell):
    #_logger.info(f'_check_cell[{cell.coordinate}]: {cell.value}')
    return _check_string(_get_cell_text(cell))

def _is_integer(text):
    return text is not None and text.isdigit()

_PARSE_PATTERN = re.compile(
    r'{(?P<expr>[a-zA-Z0-9_.]+)(\[(?P<index>[a-zA-Z_][a-zA-Z0-9_]*|\d+)\])?(\:(?P<modifier>[a-zA-Z_]+))?}')

def _parse_template_expr(expr):
    match = re.match(_PARSE_PATTERN, expr)
    return match.groupdict() if match else None

def _substitute(page, expr):
    try:
        fstring = '{__page__.' + expr['expr'] + '}'
        return string.Formatter().format(fstring, __page__=page)
    except:
        return None

def _copy_cell_properties(source, dest):
    # propagate border, style, font, and alignment to all rows
    dest.style = source.style
    dest.border = copy(source.border)
    dest.alignment = copy(source.alignment)
    dest.font = copy(source.font)

def _process_formula(sheet, cell, first_child_row, last_child_row):
    if cell.row > first_child_row and cell.row <= last_child_row:
        # ignore table rows that are generated by progenitor table row (already handled)
        return
    text = _get_cell_text(cell)
    if isinstance(text, str) and text[0] == '=':
        # formula detected
        column_range = f'{cell.column_letter}{first_child_row}:{cell.column_letter}{last_child_row}'
        new_formula = f'={text[1:].replace("__COL__", column_range)}'
        #_logger.info(f'formula found: {cell.column_letter}{cell.row}: {text[1:]} --> {new_formula}')
        cell.value = new_formula
        if cell.row == first_child_row:
            # handle formula inside table
            for row in range((first_child_row+1), (last_child_row+1)):
                child_cell = sheet.cell(row=row, column=cell.column)
                _copy_cell_properties(cell, child_cell)
                child_cell.value = Translator(
                    new_formula, origin=cell.coordinate).translate_formula(child_cell.coordinate)

def _map_index(column_header_map, index):
    assert index is not None
    if isinstance(index, int):
        return index
    if _is_integer(index):
        return int(index)
    return column_header_map.get(index)

def _process_table_column(page, lru, column_header_map, edit_cell, sheet, cell, parse, match, first_child_row, last_child_row):
    row = cell.row
    col = cell.column
    index = parse['index']
    cell_text = _get_cell_text(cell)
    for child in page.children:
        child_cell = sheet.cell(row=row, column=col)
        if child_cell.row != cell.row:
            # propagate border, style, font, and alignment to all rows
            _copy_cell_properties(cell, child_cell)
        if parse['expr'] == 'child':
            if index is not None:
                index = _map_index(column_header_map, index)
                item = child[int(index)]
                sub = get_text(item['text'])
                if 'edit' in item:
                    edit = item['edit']
                    if edit in edit_cell:
                        child_cell.fill = copy(edit_cell[edit].fill)
                child_cell.value = sub
            if parse['modifier'] == 'linked':
                url = _child_url(child)
                if _is_linked(url):
                    child_cell.hyperlink = _child_url(child)
                    child_cell.font = copy(edit_cell['linked'].font)
                else:
                    child_cell.font = copy(edit_cell['unlinked'].font)
            elif parse['modifier'] == 'doc_link':
                url = _child_doc_url(page, child, lru)
                if _is_linked(url):
                    child_cell.hyperlink = _child_doc_url(page, child, lru)
                    child_cell.font = copy(edit_cell['linked'].font)
                else:
                    child_cell.font = copy(edit_cell['unlinked'].font)
            elif parse['modifier'] == 'link_status':
                child_cell.value = _link_status(_child_url(child))
            elif parse['modifier'] == 'sheetname':
                #_logger.info(f'child sheetname directive: {child_cell.coordinate}, {child[0]}')
                new_value = cell_text.replace(match, _child_sheetname(page, child))
                #_logger.info(f'. replacement: {new_value}')
                child_cell.value = new_value
        elif parse['expr'] == 'empty':
            child_cell.value = ''
        row += 1

def _locate_first_child_row(sheet):
    for row in sheet.iter_rows():
        for cell in row:
            check = _check_cell(cell)
            if check:
                # form list of parsed template expressions for each in the cell
                parsed = [_parse_template_expr(e) for e in check]
                for parse in parsed:
                    # look for child cell expression
                    if parse['expr'] in ['empty', 'child']:
                        return cell.row
    return None

def _process_title(page, sheet):
    title = sheet.title
    check = _check_string(title)
    if check:
        for expr in check:
            parsed = _parse_template_expr(expr)
            sub = _substitute(page, parsed)
            if sub:
                title = title.replace(expr, sub)
    sheet.title = title

# ------------ EXPORT PAGE ---------------

_PROJECT_ROOT = Path(__file__).resolve().parents[1]
_TEMPLATE_DIR = _PROJECT_ROOT / 'resources' / 'xlsx_templates'

def export_page(page, dest_file=None, lru=None):
    # load template file that matches this kind of page
    template_file = f'{_TEMPLATE_DIR}/{page.kind}.xlsx'
    _logger.info(f'opening template file {template_file}...')
    workbook = load_workbook(filename = template_file)
    sheet = workbook.active
    max_row = sheet.max_row
    max_col = sheet.max_column
    max_col_letter = get_column_letter(max_col)
    _logger.info(f'sheet dimensions: {max_row} rows, {max_col} cols')

    _process_title(page, sheet)

    # move rows below the table downward to make room for table rows
    num_children = len(page.children)
    first_child_row = _locate_first_child_row(sheet)
    last_child_row = first_child_row + num_children - 1
    footer_range = f'A{first_child_row+1}:{max_col_letter}{max_row}'
    _logger.info(f'moving cell range: {footer_range}')
    sheet.move_range(footer_range, rows=num_children, cols=0, translate=False)

    # make a list of all cells with template expressions
    # (now that cells have been relocated to their final positions)
    edit_cell = {} # saves cells containing edit and formatting prototypes
    edits = [] # list of edits to be processed
    for row in sheet.iter_rows():
        for cell in row:
            check = _check_cell(cell)
            if check:
                # form list of parsed template expressions for each in the cell
                parsed = [_parse_template_expr(e) for e in check]
                for parse in parsed:
                    # check for formatting directives (before actually editing)
                    if parse['expr'] == 'edit':
                        # {edit} cells contain formatting for editing highlights
                        # save these for later use in a dict keyed on the edit modifier
                        edit_cell[parse['modifier']] = cell
                    else:
                        edits.append((cell, check, parsed))
            else:
                # check for and handle a formula
                _process_formula(sheet, cell, first_child_row, last_child_row)

    # form mapping from column header type to column index
    column_header_map = {}
    for i, col_type in enumerate(classify_table_columns(page)):
        column_header_map[col_type] = i

    # process all the edit expressions
    for edit in edits:
        cell, matches, parses = edit
        for match, parse in zip(matches, parses):
            if parse['expr'] in ['empty', 'child']:
                _process_table_column(page, lru, column_header_map, edit_cell, sheet, cell, parse, match, first_child_row, last_child_row)
            elif parse['expr'] == 'edit':
                # {edit} cells contain formatting for editing highlights (caught above)
                pass
            else:
                # general case: replace template expression with substitution value
                sub = _substitute(page, parse)
                if sub is not None:
                    cell.value = cell.value.replace(match, sub)
                if parse['modifier'] == 'linked':
                    cell.hyperlink = page.url
                    cell.font = copy(edit_cell['linked'].font)
                if parse['modifier'] == 'date':
                    cell.value = _format_date(cell.value)

    # all done, save and return
    if dest_file:
        workbook.save(dest_file)
    return workbook
